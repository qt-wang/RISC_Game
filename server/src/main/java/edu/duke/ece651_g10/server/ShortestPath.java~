package edu.duke.ece651_g10.server;

public class ShortestPath {
    GameMap gMap;
    Territory source;
    Territory target;
    HashMap<Territory, Integer> distanceTable;
    Vector<Territory> visited;
    Vector<Territory> unvisited;

    private void initiateDistanceTable(){
        distanceTable = new HashMap<>();
        Player player = source.getOwner();
        for(Territory t : gMap.getTerritoriesForPlayer(player)){
            distanceTable.put(t, Integer.MAX_VALUE);
        }
        distanceTable.put(source, 0);
    }

    private void initiateSet(){
        this.visited = new Vector<>();
        this.unvisited = new Vector<>();
        Player player = source.getOwner();
        for(Territory t : gMap.getTerritoriesForPlayer(player)){
            unvisited.add(t);
        }
    }
    public ShortestPath(GameMap gMap){
        this.gMap = gMap;
        initiateDistanceTable();
        initiateSet();
    }

    public int minCost(){
        int size1 = visited.size();
        visited.add(source);
        int size2 = visited.size();

        while((size2 - size1) != 0) {
            size1 = visited.size();
            Territory t = visited.lastElement();
            Set<Territory> neigh = t.getNeighbours();
            Territory minTerritory = source;
            int shortest = Integer.MAX_VALUE;
            for (Territory n : neigh) {
                if (!visited.contains(n)) {
                    if (shortest > distanceTable.get(t) + n.getSize()) {
                        shortest = distanceTable.get(t) + n.getSize();
                        minTerritory = n;
                    }
                    int minDistance = Math.min(distanceTable.get(n), distanceTable.get(t) + n.getSize());
                    distanceTable.put(n, minDistance);
                }
            }
            if(!visited.contains(minTerritory)) {
                visited.add(minTerritory);
            }
            size2 = visited.size();
        }
        return distanceTable.get(target);
    }
}

